//0x7ff020905fe8: target rip
//0x7ff020905fe0: target rip
//0x7ff020905fd8: rax
//0x7ff020905fd0: rcx
//0x7ff020905fc8: addr of store_context
//0x7ff020905fc0: addr of int3_store_context
//0x7ff020905fb8: addr of pf_store_context
//0x7ff020905fb0: addr of selfw_store_context
//remember to modify the addr of f_trampoline and re_enter in ../control/hello.c
//remember to modify the addr of first_exit and second_exit in imee.c

void entry_gate (void);
asm (" .text");
asm (" .type    entry_gate, @function");
asm ("entry_gate: \n");
asm ("movq $0x0, %rax \n");
asm ("movq $0x0, %rcx \n");
asm ("vmfunc \n");
asm ("lea 0x6(%rip), %rax \n");
asm ("lea (%rax, %rcx, 4), %rax \n");
asm ("jmpq *%rax \n");
// // asm ("vmcall \n");
asm ("movq 0x5d3a(%rip), %rax \n");
asm ("movq 0x5d2b(%rip), %rcx \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("jmpq *0x5d1f(%rip) \n");

/* TODO: pass ana_stack & ana_handler into here */
void first_exit (void);
asm (" .text");
asm (" .type    first_exit, @function");
asm ("first_exit: \n");
// asm ("vmcall \n");
asm ("movq %rcx, 0x5d08(%rip) \n");
asm ("movq %rax, 0x5d09(%rip) \n");//since rsp stores rax
asm ("movq $0x0, %rax \n");
asm ("movq $0x9, %rcx \n");
asm ("vmfunc \n");
// asm ("vmcall \n");
asm ("jmpq *0x5ce2(%rip) \n");//jump to store_context
// asm ("vmcall \n");
// asm ("REX.W ljmp *0x199b(%rip) \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
asm ("nop \n");

// void re_enter (void);
// asm (" .text");
// asm (" .type    re_enter, @function");
// asm ("re_enter: \n");
// asm ("vmfunc \n");
// // asm ("vmcall \n");
// asm ("movq 0x2cfe(%rip), %rcx \n");
// asm ("movq 0x2cff(%rip), %rax \n");
// asm ("movq 0x2d00(%rip), %rsp \n");
// asm ("jmpq *0x2d02(%rip) \n");

void int3_exit1 (void);
asm (" .text");
asm (" .type    int3_exit1, @function");
asm ("int3_exit1: \n");
// asm ("vmcall \n");
// asm ("movq %mm0, %rax; \n\t");
// asm ("rdfsbase %rax; \n\t");
// asm ("pop %rax \n");
asm ("movq %rcx, 0x5cd5(%rip) \n");
asm ("movq %rax, 0x5cd6(%rip) \n");
// asm ("movq %rsp, 0x5cee(%rip) \n");
// asm ("movq $0xffffffff8108fd59, %rax \n");//save the next instruction in 0x7ff020902fe8
// asm ("movq %rax, 0x2986(%rip) \n");//save the next instruction in 0x7ff020902fe8
asm ("movq $0x0, %rax \n");
asm ("movq $0x9, %rcx \n");
asm ("vmfunc \n");
// asm ("mov 0x5cc2(%rip), %rdx \n");
// asm ("vmcall \n");
asm ("jmpq *0x5ca7(%rip) \n");//jump to int3_store_context1
// asm ("vmcall \n");
// asm ("REX.W ljmp *0x199b(%rip) \n");

// void int3_enter1 (void);
// asm (" .text");
// asm (" .type    int3_enter1, @function");
// asm ("int3_enter1: \n");
// asm ("movq $0x0, %rax \n");
// asm ("movq $0x0, %rcx \n");
// asm ("vmfunc \n");
// // asm ("vmcall \n");
// asm ("movq 0x5cc9(%rip), %rcx \n");
// asm ("movq 0x5cca(%rip), %rax \n");
// asm ("lea 0x6(%rip), %rax \n");
// asm ("lea (%rax, %rcx, 4), %rax \n");
// asm ("jmpq *%rax \n");
// // asm ("movq 0x5ccb(%rip), %rsp \n");
// // asm ("mov 0x5ccc(%rip), %rdx \n");
// // asm ("vmcall \n");
// 
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// // asm ("push 0xff(%rbx) \n");
// // asm ("vmcall \n");
// // asm ("mov 0x5c8d(%rip), %rbx \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("jmpq *0x5cb7(%rip) \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");

void pf_exit1 (void);
asm (" .text");
asm (" .type    pf_exit1, @function");
asm ("pf_exit1: \n");
// asm ("vmcall \n");
// asm ("movq %mm0, %rax; \n\t");
// asm ("rdfsbase %rax; \n\t");
// asm ("pop %rax \n");
asm ("movq %rcx, 0x5cb0(%rip) \n");
asm ("movq %rax, 0x5cb1(%rip) \n");
// asm ("movq %rsp, 0x5c6b(%rip) \n");
// asm ("movq $0xffffffff8108fd59, %rax \n");//save the next instruction in 0x7ff020902fe8
// asm ("movq %rax, 0x2986(%rip) \n");//save the next instruction in 0x7ff020902fe8
asm ("movq $0x0, %rax \n");
asm ("movq $0x9, %rcx \n");
asm ("vmfunc \n");
// asm ("mov 0x5cc2(%rip), %rdx \n");
// asm ("vmcall \n");
asm ("jmpq *0x5c7a(%rip) \n");//jump to int3_store_context1
// asm ("vmcall \n");
// asm ("REX.W ljmp *0x199b(%rip) \n");

// void pf_enter1 (void);
// asm (" .text");
// asm (" .type    pf_enter1, @function");
// asm ("pf_enter1: \n");
// asm ("vmfunc \n");
// // asm ("vmcall \n");
// asm ("movq 0x5c3a(%rip), %rcx \n");
// asm ("movq 0x5c3b(%rip), %rax \n");
// asm ("movq 0x5c3c(%rip), %rsp \n");
// asm ("jmpq *0x5c3e(%rip) \n");
// // asm ("mov 0x5ccc(%rip), %rdx \n");
// // asm ("vmcall \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// // asm ("push 0xff(%rbx) \n");
// // asm ("vmcall \n");
// // asm ("mov 0x5c8d(%rip), %rbx \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");
// asm ("nop \n");

void read_populate (void);
asm (" .text");
asm (" .type    read_populate, @function");
asm ("read_populate: \n");
// asm ("vmcall \n");
asm ("movq (%rax), %rax \n");
// asm ("vmcall \n");
asm ("movq $0xabcd, %rax \n");
// asm ("mov 0x5ccc(%rip), %rdx \n");
asm ("vmcall \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");

void write_populate (void);
asm (" .text");
asm (" .type    write_populate, @function");
asm ("write_populate: \n");
// asm ("vmcall \n");
asm ("movq %rcx, 0x5bf0(%rip) \n");
asm ("movq %rax, 0x5bf1(%rip) \n");
asm ("movq %rsp, 0x5bf2(%rip) \n");
asm ("movq $0x0, %rax \n");
asm ("movq $0x0, %rcx \n");
asm ("vmfunc \n");
asm ("jmpq *0x5bab(%rip) \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
// asm ("movq $1, (%rax) \n");
// asm ("movq $0xabcd, %rax \n");
// // asm ("mov 0x5ccc(%rip), %rdx \n");
// asm ("vmcall \n");
// asm ("movq $1, (%rax) \n");
// asm ("movq $0xabcd, %rax \n");
// // asm ("mov 0x5ccc(%rip), %rdx \n");


void subject (void);
asm (" .text");
asm (" .type    subject, @function");
asm ("subject: \n");
// asm ("vmcall \n");
asm ("pushq %rbp \n");
asm ("movq %rsp, %rbp \n");
asm ("movq $0x0, -0x10(%rbp) \n");
asm ("movq -0x10(%rbp), %rax \n");
asm ("movq %rax, -0x8(%rbp) \n");
asm ("movq -0x8(%rbp), %rax \n");
asm ("movq %rax, -0x28(%rbp) \n");
asm ("movq $0x0, -0x20(%rbp) \n");
asm ("rdtsc \n");
asm ("movq %rax, -0x8(%rbp) \n");
asm ("jmp cmp \n");
asm ("loop: \n");
asm ("movq $0x0, -0x18(%rbp) \n");
asm ("inner_loop: \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
//
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("nop \n");
asm ("addq $0x1, -0x18(%rbp) \n");
asm ("cmpq $0x3e7, -0x18(%rbp) \n");
asm ("jbe inner_loop \n");
asm ("addq $0x1, -0x20(%rbp) \n");
asm ("cmp: \n");
asm ("cmpq $0x3e7, -0x20(%rbp) \n");
// asm ("cmpq $0x30d40, -0x20(%rbp) \n");
// asm ("cmpq $100000, -0x20(%rbp) \n");
// asm ("cmpq $10000, -0x20(%rbp) \n");
asm ("jbe loop \n");
asm ("rdtsc \n");
asm ("movq %rax, -0x10(%rbp) \n");
asm ("movq -0x8(%rbp), %rax \n");
asm ("movq -0x10(%rbp), %rdx \n");
asm ("sub %rax, %rdx \n");
// asm ("movq $0x7ff020901fd0, %rax \n");
// asm ("movq (%rax), %rdi \n"); //num of bp hit
// asm ("movq %rdx, %rax \n");
// asm ("add %rax, -0x28(%rbp) \n");
// asm ("movq -0x28(%rbp), %rdi \n");//store the cpu cycles in rdi
asm ("vmcall \n");


